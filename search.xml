<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title><![CDATA[Redis 入门]]></title>
    <url>%2F2020%2F02%2F03%2FRedisFirst%2F</url>
    <content type="text"><![CDATA[NoSQLNoSQL是一类新出现的数据库，不支持SQL语法，也不是关系型数据库，而是基于KEY-VALUE方式存储数据。他们没有通用的语言，而是各自有各自的语法和用法。他们往往适用于关系简单，而对事务强的业务有很好的支持。 NoSQL数据库常见的有： Mongodb Redis Hadoop Redis 简介官方网站参考文档 支持数据的持有化 不仅支持key-value，还支持list，set，zset，hash等结构。 支持数据备份 性能极高 拥有丰富的数据类型 操作都是原子性的 Redis常常用来做缓存，其读写效率很高，适用于社交平台等大型系统等。 Redis 安装与配置安装配置打开配置文件redis.conf bind：绑定的IPport：绑定的端口daemonizs：是否为守护进程（改为yes）dbfilename：数据存储文件名dir：存储路径logfile：日志文件database：数据库数量slaveof：设置主从（一般不用） 启动1234567891011121314# 直接运行sudo redis-server /etc/redis/redis.confps -ef | grep redis # 得到PID号sudo kill -9 PID号# 以服务方式运行sudo service redis startsudo service redis stop# 进入redis，默认进入0号数据库redis-cli# redis-cli 命令ping # ping数据库select 5 # 切换数据库 Redis数据类型 string：字符串，可以接受任意二进制数据，最大可容纳512MB。 hash：哈希，用于存储对象，包含属性、值，值的类型为string。 list：列表，每个元素都是string，按照插入顺序排序。 set：集和（无序），元素具有唯一性，且不可修改。 zset：有序集和，元素具有唯一性，且每个元素具有一个权重，并按照权重从小到大排序，也是没有修改操作。 数据操作基本操作123456789# 键命令keys pattern # 支持正则表达式keys * # 查看所有键keys 'a*' # 查看所有a开头的键exists key # 查看是否存在键type key # 查看类型del key # 删除键expire key seconds # 设置过期时间ttl key # 查看键的剩余时间 字符串操作123456789# 保存set key valuesetex key seconds value # 设置过期时间mset key1 value1 key2 value2 # 设置多个键值append key value # 追加值# 获取get key # 如果不存在返回(nil)mget key1 key2 key3 哈希操作12345678910# 设置hset key field value # 设置单个属性hmset key field1 value1 field2 value2 # 设置多个值# 获取hkeys key # 获取属性hget key field # 获取值hmget key field1 field2 # 获取多个值hvals key # 获取所有值# 删除hdel key field1 field2 # 删除属性 执行hset可能会抛出无法保存快照的错误，可以执行如下命令：1config set stop-writes-on-bgsave-error no 列表操作123456789# 插入lpush key value1 value2 # 左侧插入rpush key value1 value2 # 右侧插入linsert key before/after old_key new_key # 在old_key前/后插入数据new_key# 显示lrange key start stop # 从几到几，-1表示最后一个# 修改lset key index value lrem key count value # 删除几个某元素，0表生所有；&gt;0表示从左向右；&lt;0表示从右向左 集和操作123456# 增加sadd key value1 value2 # 获取smmbers key # 获取所有元素# 删除srem key value1 value2 # 删除某些元素 有序集和123456789# 增加zadd key score1 member1 score2 member2# 获取zrange key start stop zrangebyscore key min max # 查看权重在区间的元素zscore key member # 查看权值# 删除zrem key member1 member2zremrangebyscore key min max # 删除权重在区间的元素 与 Pyhton 交互安装Redis包1pip install redis 使用123456789from redis import *# 连接数据库，参数：主机名；端口；数据库编号sr = StrictRedis(host='localhost', port=6379, db=0)res = sr.set('key', 'value') # 返回布尔值，表示是否成功。res = sr.get('key') # 如果有，返回该值；没有，返回Noneres = sr.delete('key') # 返回删除成功的数量res = sr.keys(pattern='*') # 返回列表 配置Django中保存session到Redis1pip install django-redis-sessions 在setting.py中配置Redis1234567SESSION_ENGINE = 'redis_sessions.session'SESSION_REDIS_HOST = 'localhost'SESSION_REDIS_PORT = 6379SESSION_REDIS_DB = 2SESSION_REDIS_PASSWORD = '' # 键前缀SESSION_REDIS_PREFIX = 'session' 使用方法依然不变12request.session['key'] = 1num = request.session['key'] Redis 主从在Redis中，主从的数据是共享的，也就是实现了数据的冗余保存，这样可以防止一台机器挂掉后数据丢失的问题。一个Redis主机可以有多个从机，一个从机也可以有多个从机。写数据要在主机中，从机可以读取数据。这样也可以实现数据的读写分离。一般情况下，一个网站的数据读写比例为 10:1 ，因此可以配置多个从机用于读取数据。 主机配置可以保存不变，只是IP地址应该使用局域网或公网IP。配置完成运行服务。从机配置，并启动。123bind 本机IPslaveof 主机IP 主机PORTport 从机PORT，不能与主机冲突 查看某机角色以及状态。1redis-cli -h 某机IP -p 某机PORT info Replication Redis 集群当用户量达到一定量级时，就需要将Redis服务规模升级为集群。 配置过程首先配置3个配置文件， 12345678port 7000bind 本机IPdaemonize yespidfile 7000.pidcluster-enabled yescluster-config-file 7000_node.confcluster-node-timeout 15000appendonly yes 12345678port 7001bind 本机IPdaemonize yespidfile 7001.pidcluster-enabled yescluster-config-file 7001_node.confcluster-node-timeout 15000appendonly yes 12345678port 7002bind 本机IPdaemonize yespidfile 7002.pidcluster-enabled yescluster-config-file 7002_node.confcluster-node-timeout 15000appendonly yes 之后依据这3个配置文件启动3个Redis服务。 使用命令运行集群12345678# 复制程序sudo cp /usr/share/doc/redis-tools/examples/redis-trib.rb /usr/local/bin# 安装依赖sudo gem install redis# 安装Ruby，保证是最新版sudo apt-get install ruby# 创建集群redis-trib.rb create --replicas 1 IP_1:PORT_1 IP_2:PORT_2 IP_3:PORT_3 创建完成后，会输出几个Redis主机和从机，几个主机分别存储一部分数据，按数据槽存储，槽编号范围是0 ~ 16383。 与Python交互1pip install redis-cluster 123456789101112from rediscluster import *startup_nodes = [ &#123;'host': '', 'port': PORT_1&#125; # Redis主机]src = StrictRedisCluster( startup_nodes=startup_nodes, decode_responses=True)result = src.set('key','val')]]></content>
      <categories>
        <category>Web 开发</category>
      </categories>
      <tags>
        <tag>Redis</tag>
        <tag>NoSQL</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Django 入门]]></title>
    <url>%2F2020%2F01%2F30%2FDjangoFirst%2F</url>
    <content type="text"><![CDATA[绪论Django 3 官方参考文档点击进入 Django 2.2 官方参考文档点击进入 Django 2.2 其他参考文档点击进入 Django 1.11 官方参考文档点击进入（英文） Django 1.11 中文参考文档点击进入 Django 2 及后续版本不再支持 Python 2； Django 3 及后续版本不再支持 Python 3.5 及以下版本。 Django 1 与 2 的区别主要区别如下： url 用法：Django 1 主要使用 url 来配置，参数部分使用()做匹配；Django 2 使用 path 来配置，参数部使用&lt;&gt;做匹配，不支持传统的正则表达式。这里Django 2 兼容 Django 1 ，可以用re_path来做Django 1中url的操作。 路由分发 include。 ORM 外键：Django 2 的外键必须加on_delete属性 参考文章一参考文章二 Django 3.0 新特性（2019年12月 推出） 仅支持 Python 3.6以上版本。 支持使用 MariaDB 10.1 或更高版本的数据库。 开始将新增对 ASGI 的支持。这意味着 Django 3 可以支持异步操作，消除阻塞操作对程序的影响。 新增枚举类型 TextChoices 和 IntegerChoices 类。 枚举示例：12345678910111213141516171819class Student(models.Model): FRESHMAN = 'FR' SOPHOMORE = 'SO' JUNIOR = 'JR' SENIOR = 'SR' GRADUATE = 'GR' YEAR_IN_SCHOOL_CHOICES = [ (FRESHMAN, 'Freshman'), (SOPHOMORE, 'Sophomore'), (JUNIOR, 'Junior'), (SENIOR, 'Senior'), (GRADUATE, 'Graduate'), ] year_in_school = models.CharField( max_length=2, choices=YEAR_IN_SCHOOL_CHOICES, default=FRESHMAN, ) Django 基本操作django-admin 基本命令12345678910django-admin startproject # 创建Django项目django-admin startapp # 创建Django应用django-admin check # 检查项目完整性django-admin test # 执行单元测试django-admin runserver # 启动服务器django-admin shell # 进入Django Shelldjango-admin makemigrations # 创建数据库迁移文件django-admin migrate # 执行迁移文件django-admin dumpdata # 导出数据库数据django-admin loaddata # 导入数据库数据 目录结构项目结构 A （本次使用） Project # 项目目录 manage.py # 项目管理文件 project_name # 项目配置目录 asgi.py # Django 3.0 新增文件 settings.py # 项目配置 urls.py # 项目路由 wsgi.py # Web 与 Django 交互入口 my_app # 创建的Django应用目录 migrations # 数据库迁移文件目录 static # 静态文件目录 templates # 模板目录 index.html templatetags # 自定义标签过滤器目录 __init__.py urls.py # 应用路由 apps.py # 应用声明 models.py # 应用模型 test.py # 单元测试 admin.py # Admin模块 views.py # 应用视图 创建过程如下：1234567django-admin startproject project_namecd project_namedjango-admin startapp my_appcd my_appmkdir templatesmkdir templatetagsmkdir static 项目结构 B部分Django项目也会用到这种结构，即将模板，过滤器，静态文件等目录放在应用的外部。 Project manage.py project_name settings.py urls.py wsgi.py （ Web 与 Django 交互入口） templates my_app_templates index.html templatetags # 自定义标签过滤器 __init__.py my_app migrations urls.py apps.py models.py test.py admin.py views.py 配置过程123456789101112131415161718192021222324252627282930313233343536373839404142# 每创建一个应用，都要在项目setting.py中声明该应用INSTALLED_APPS=[ ... 'my_app', # 或写成 'my_app.apps.MyAppConfig' # 具体可以到应用的apps.py文件中查看命名]# 配置项目的数据库，可以保持默认SQLiteDATABASES=[ 'default': &#123; 'ENGINE': 'django.db.backends.sqlite3', 'NAME': os.path.join(BASE_DIR, 'db.sqlite3'), &#125;]# 如果要改为MySQL，配置如下。注意：首次运行可能需要安装所提示的Python扩展包。DATABASES=[ 'default': &#123; 'ENGINE': 'django.db.backends.mysql', 'NAME': '数据库名称', # 必须手动创建 'USER': 'root', 'PASSWORD': '123456', 'HOST': 'localhost', 'PORT': 3306, &#125;]# 如果使用项目结构 B，则做下面的配置，配置要渲染的模板的目录TEMPLATES = [ ... 'DIR' = [os.path.join(BASE_DIR, 'templates')] ...]# 修改默认语言和时区LANGUAGE_CODE = 'zh-hans'TIME_ZONE = 'Asia/Shanghai'# 如果项目完成后，在交付阶段，要将DEBUG关闭，并配置允许访问的主机DEBUG = FalseALLOWED_HOSTS = ['*'] 配置完成后，在应用my_app下的views.py中添加一个简易的视图：123456from django.shortcuts import renderfrom django.http import HttpResponsedef hello(request): return HttpResponse("Hello World") 同时应该配置路由文件，在my_app中创建并配置urls.py。 1234567# Django 2.0 以上推荐此写法，后续写法均为 2.0 写法。from django.urls import path, re_path, includeimport my_app.viewsurlpatterns = [ path('hello/', my_app.views.hello),] 12345678910# Django 1.11 以及之前的写法。from django.conf.urls import url, includeimport my_app.viewsurlpatterns = [ # 写法 1：这里的'hello'是按照字符串进行匹配，如果用户写作helloabcd，也会命中该记录，如果想修正这种错误，可以写作'hello/'。 url('hello', my_app.views.hello), # 写法 2：使用正则表达式，r表示该串为正则表达式，^与$分别标记了正则表达式匹配的开始和结尾，这样，用户写helloabcd就不会命中了。使用正则表达式的好处，例如匹配GET参数等，都会使操作变得很方便。 url(r'^hello/$', my_app.views.hello),] 之后再配置项目路由器：1234567from django.contrib import adminfrom django.urls import path, includeurlpatterns = [ path('admin/', admin.site.urls), path('my_app/', include('my_app.urls'))] 配置到这里就可以运行项目看效果了。1python manage.py runserver 8080 进入如下地址，出现Hello World就算配置成功了。http://127.0.0.1:8080/my_app/hello/ Django 模型模型（Models）是用于对接数据库的接口，在所有的MVC应用中都是如此。Django的模型的定义如下： 数据类型 整型：IntegerField 定长文本：CharField 不定长文本：TextField 日期：DataField 时间：TimeField 日期时间：DateTimeField 自增ID：AutoField （可以不定义，自动生成） 布尔：BooleanField Null型布尔：NullBooleanField 十进制浮点数：DecimalField （精度更高，例如钱数） 浮点型：FloatField 文件：FileField 图片：ImageField 主要属性 主键：primary_key 长度：max_length 默认值：default 唯一性：unique（不允许重复出现） 索引：db_index 自定义字段名称：db_column 是否允许为空：null 是否允许空白：blank 十进制浮点数： 数字数：max_digits 小数点数：decimal_places 日期（二者只能用一个） 更新时间：auto_now 创建时间：auto_now_add 外键：’其他表’ （赋值时直接写该对象，2.0以上版本还要求on_delete属性） 创建模型1234567891011121314151617181920212223from django.db import modelsclass MyBookModel(models.Model): # 注意：属性名不能出现两个连续的下划线， # title title = models.CharField(max_length=20) # publish_date publish_date = models.DateTimeField(auto_now=True) # author author = models.ForeignKey('AuthorModel', on_delete=models.CASCADE) # Django 1 版本中不要求on_delete def __str__(self): return self.titleclass AuthorModel(models.Model): # name name = models.CharField(max_length=20) # age age = models.IntegerField(default=0) def __str__(self): return self.name 完成后，迁移数据库到sqlite：12python manage.py makemigrationspython manage.py migrate 使用模型简单查询操作 get：返回模型对象；查到多条或是未查到都会抛出异常。 all：返回查询集；返回所有数据 filter：返回查询集；返回满足条件的数据 exclude：返回查询集；返回不满足条件的数据 order_by：返回查询集；对查询结果排序 对于 get，filter，exclude 这三个查询操作，可以填写查询条件，例如：123456789101112131415161718192021222324252627# 精确查询MyBookModel.objects.get(id=1)MyBookModel.objects.get(title__exact="First Book") # 同 title="First Book"# 模糊查询MyBookModel.objects.filter(title__contains="First")MyBookModel.objects.filter(title__startswith="First")MyBookModel.objects.filter(title__endswith="Book")# 空查询MyBookModel.objects.filter(title__isnull=False)# 范围查询MyBookModel.objects.filter(id__in=[1, 3, 5])# 比较查询MyBookModel.objects.filter(id__gt=2)MyBookModel.objects.filter(id__lt=2)MyBookModel.objects.filter(id__gte=2)MyBookModel.objects.filter(id__lte=2)# 日期查询MyBookModel.objects.filter(publish_date__year=1990)MyBookModel.objects.filter(publish_date__month=2)MyBookModel.objects.filter(publish_date__day=2)MyBookModel.objects.filter(publish_date__gt=date(1980,3,2))# 排序MyBookModel.objects.all().order_by('id', 'title') # 升序MyBookModel.objects.all().order_by('-id') # 降序，前面加一个 减号# 查看是否有数据m = MyBookModel.objects.filter(id=1)m.exists() 也就是说，其参数格式为模型属性名__条件名=值。（注意是双下划线） 高级查询操作1234567891011121314151617181920from django.db.models import F, Q# 直接书写，默认为“且”的关系MyBookModel.objects.filter(id__gt=2, title__contains="First")# Q 对象，实现“与或非”的关系MyBookModel.objects.filter(Q(id__gt=2) &amp; Q(title__contains="First")) # 且的关系MyBookModel.objects.filter(Q(id__gt=2) | Q(title__contains="First")) # 或的关系MyBookModel.objects.filter(~Q(id=2)) # id 不为 2# F 对象，实现“属性（字段）”之间的比较MyBookModel.objects.filter(publish_date=F('publish_date')) # 查询出版日期与出版日期相等的对象MyBookModel.objects.filter(publish_date=F('publish_date') / 3) # 查询出版日期与出版日期除以三相等的对象# 聚合函数 sum count avg max minfrom django.db.models import Sum, Count, Avg, Max, MinMyBookModel.objects.all().aggregate(Count('id')) # 返回字典 &#123;'id_count': 2&#125;MyBookModel.objects.aggregate(Count('id')) # 返回字典 &#123;'id_count': 2&#125;，与前者功能一致MyBookModel.objects.filter(id__gt=2).count() # id 大于 2 的记录数目 查询集： 惰性查询：只有需要具体数据的时候才发生查询。 缓存：第一次查询到的查询集数据会缓存下来，第二次再访问这个查询集的时候就会使用缓存的内容。 切片：对一个查询集切片会产生新的查询集，且切片参数不可为负数。 模型关系模型（数据表）关系分为： 一对一 一对多 多对多 关系属性： 多对多：ManyToManyField(‘表名’)，可以任意定义到其中一个模型中。 一对一：OneToOneField(‘表名’)，可以任意定义到其中一个模型中。 多对一：ForeignKey(‘表名’)，定义在多的模型中。 关联查询（一对多）1234567891011# 查询一表一表.objects.filter(多表__属性__条件='...') # 这里的多表要小写AuthorModel.objects.filter(mybookmodel__title__contains='First')# 查询多表多表.objects.filter(外键__属性__条件='...') MyBookModel.objects.filter(author__name__contains='W')# 查询多表查询集x = 一表.objects.get(id=1)查询集y = 查询集.多表_set.all() # 多表也要小写x = AuthorModel.objects.get(id=1)y = x.mybookmodel_set.all() 插入，更新与删除使用举例：1234567891011121314151617181920212223242526from my_app.models import AuthorModel, MyBookModelfrom datetime import date# 创建一条作者记录a = AuthorModel()a.name = "Wang"a.age = 80a.save()# 创建一条作者记录a = AuthorModel.objects.create(name='Li', age=10)# 创建一条书籍记录m = MyBookModel()m.title = "First Book"m.date = date(1999,1,1)m.author = am.save()# 修改m = MyBookModel.objects.get(id=1)m.title = "Second Book"m.save()# 删除m = MyBookModel.objects.get(id=1)m.delete() 自关联自关联是一种特殊的一对多关系，例如“省-&gt;市-&gt;县”的关系。设计这种关系，一种方法是设计三张表，利用外键关联三个表；另外一种方法是将他们设计到一张表中，利用一个字段指向其父级ID，这样就形成了自关联的关系。 123456class AreaModel(models.Model): title = models.CharField(max_length=100) parent = models.ForeignKey('self', null=True, blank=True, on_delete=False) def __str__(self): return self.title on_delete有CASCADE、PROTECT、SET_NULL、SET_DEFAULT、SET()五个可选择的值。 CASCADE：此值设置，是级联删除。PROTECT：此值设置，是会报完整性错误。SET_NULL：此值设置，会把外键设置为null，前提是允许为null。SET_DEFAULT：此值设置，会把设置为外键的默认值。SET()：此值设置，会调用外面的值，可以是一个函数。 管理器 objects就是MyBookModel.objects的objects。自制管理器的优势有： 改变查询结果 添加个性化方法 自制管理器的方式如下：1234567891011121314151617181920212223242526class AuthorModelManager(models.Manager): def all(self): a = super().all() return a.filter(age__gt=10) # 此方法与下面的create任选一个： def create_author(self, name, age): a = self.model() # a = AuthorModel() a.name = name a.age = age a.save() return aclass AuthorModel(models.Model): ... # 管理器 objects = AuthorModelManager() ... @classmethod def create(cls, name, age): a = cls() a.name = name a.age = age a.save() return a 一旦自制了管理器，原来的管理器就自动失效了（就算名字不是objects，原objects也会失效）。 元选项在数据库中，数据表的命名是项目名_模型名，但是一旦项目名发生变化，所有的表的命名都会受到影响。如果消除这种影响，可以在模型类里面定义一个元类： 12345class AuthorModel(models.Model): ... class Meta: # 指定表名 db_table = 'author_table' 在某些版本的SQLite中不支持数据表改名，所以这一步操作要注意。 导入导出数据12python manage.py dumpdata &gt; data.jsonpython manage.py loaddata data.json Django 视图静态视图在my_app下创建templates文件夹，在该文件夹下创建index.html，编辑index.html。12345678910&lt;!DOCTYPE html&gt;&lt;html lang="en"&gt;&lt;head&gt; &lt;meta charset="UTF-8"&gt; &lt;title&gt;Title&lt;/title&gt;&lt;/head&gt;&lt;body&gt;&lt;h1&gt;Hello&lt;/h1&gt;&lt;/body&gt;&lt;/html&gt; 编辑视图函数：123456789101112from django.http import HttpResponsefrom django.shortcuts import render# 第一种方式，直接返回纯文本def hello(request): return HttpResponse('Hello')# 第二种方式，返回模板def index(request): return render(request, 'index.html') 修改后记着修改对应的urls：12345678from django.urls import path, includeimport my_app.viewsurlpatterns = [ path('hello', my_app.views.hello), path('index', my_app.views.index)] 动态视图模板系统基本语法：123变量标签：&#123;&#123; 变量 &#125;&#125;for循环标签：&#123;% for x in list %&#125;, &#123;% endfor %&#125;if-else标签：&#123;% if %&#125;, &#123;% else %&#125;, &#123;% endif %&#125; 首先编辑好前端页面，label_list是要输出的标签。这里我们创建books.html文件，编辑如下：123456789101112&lt;!DOCTYPE html&gt;&lt;html lang="en"&gt;&lt;head&gt; &lt;meta charset="UTF-8"&gt; &lt;title&gt;Title&lt;/title&gt;&lt;/head&gt;&lt;body&gt;&#123;% for x in label_list %&#125;&lt;h1&gt;&#123;&#123; x.title &#125;&#125;&lt;/h1&gt;&#123;% endfor %&#125;&lt;/body&gt;&lt;/html&gt; 模板渲染：后台给要输出的标签赋值：12345def get_them(request): get_all = MyBookModel.objects.all() return render(request, 'books.html', &#123; 'label_list': get_all &#125;) 修改后，别忘了修改urls.py文件。1234urlpatterns = [ path('index/', my_app.views.index), path('get_books/', my_app.views.get_books),] 如果想自己做一个渲染器，可以这样做：1234567from django.template import loader, RequestContextdef my_render(request, template, args): temp = loader.get_template(template) context = RequestContext(request, args) res_html = temp.render(context) return HttpResponse(res_html) http://127.0.0.1:8080/my_app/index/http://127.0.0.1:8080/my_app/get_books/ 依据ID进行路由跳转首先建立模板one_book.html：123456789101112&lt;!DOCTYPE html&gt;&lt;html lang="en"&gt;&lt;head&gt; &lt;meta charset="UTF-8"&gt; &lt;title&gt;Title&lt;/title&gt;&lt;/head&gt;&lt;body&gt;&lt;h1&gt;&#123;&#123; item.title &#125;&#125;&lt;/h1&gt;&lt;h2&gt;&#123;&#123; item.author &#125;&#125;&lt;/h2&gt;&lt;/body&gt;&lt;/html&gt; 在my_app的urls里面修改：1path('get_the_book/&lt;int:bid&gt;', my_app.views.get_the_book) 相应修改views.py：123456def get_the_book(request, bid): bid = int(bid) get_one = MyBookModel.objects.get(id=bid) return render(request, 'one_book.html', &#123; 'item': get_one &#125;) 页面重定向跳转方法：123456789def create(request): a = AuthorModel.objects.get(id=1) m = MyBookModel() m.title = "Second Book" m.author = a m.save() return HttpResponseRedirect('/my_app/index') 自定义 404 等错误页面在项目urls.py中配置：1234import django.conf.urlsdjango.conf.urls.handler404 = 'my_app.views.error404'django.conf.urls.handler500 = 'my_app.views.error500' 同时设计相应的错误页面。要查看效果，就要关闭DEBUG模式才可以。123456def error404(request): return HttpResponse('Error handler content', status=404) # return render(request, 'error404.html', status=404)def error500(request): return HttpResponse('Error handler content', status=500) 管理静态文件通常一些静态文件，如网站logo等资源需要单独存放到一个固定的位置，一般是存放到静态文件目录下。配置静态文件目录过程为： 确保 INSTALLED_APPS 包含了 django.contrib.staticfiles。 在配置文件中，定义 STATIC_URL，例子:STATIC_URL = &#39;/static/&#39; 在模板中，用 static 模板标签基于配置 STATICFILES_STORAGE 位给定的相对路径构建 URL。 12&#123;% load static %&#125;&lt;img src="&#123;% static 'image/example.jpg' %&#125;" alt="My image"&gt; 将你的静态文件保存至程序中名为 static 的目录中。例如 my_app/static/image/example.jpg。 表单表单的提交常见有两种方式：GET与POST。在Request中包含了浏览器的请求信息，Request的属性包括： POST：POST请求参数，查询字典（QueryDict）类型 GET：GET请求参数，查询字典（QueryDict）类型 FILES：上传的文件，类似于字典的对象 COOKIES：客户端的cookies，一个Python字典 path：表示请求路径，不包括域名与参数 method：表示请求方式 encoding：提交数据的编码，默认utf8 session：服务端session 用法如下123456789def set_author(request): args = request.POST # 写法 1：如果没有该参数则返回None name = args.get('name') name = args.get('name', "Anonymous") # 第二个参数表示默认值，即没有参数的时候返回该默认值 name = args.getlist('name') # 返回name参数的多个值，因为允许一个参数含有多个值 # 写法 2：如果没有该参数则抛出异常KeyError name = args['name'] return HttpResponseRedirect('/my_app/index') Ajax 请求123456789from django.http import JsonResponsedef get_author(request): a = AuthorModel.objects.get(id=1) j = &#123; 'name': 'Wang' 'age': 20 &#125; return JsonResponse(j) Cookie 与 SessionCookie：保存在客户端，由服务器生成，客户端访问服务器时会附带Cookies。另外Cookies是会过期的，如果不指定，则有效期为关闭浏览器时。Session：保存在服务端，也是由服务器生成，依赖于Cookie，因为客户标识码SessionID存储在Cookie里面。Session存储位置在数据库中。 Cookie12345678910# 设置 Cookiesresponse = HttpResponse('')response.set_cookie('num', 1, max_age=7*24*3600) # 从现在开始计算过期时间，单位：秒response.set_cookie('num', 1, expires=timedelta(days=7)+datetime.now()) # 从指定时间计算，单位：秒return response# 读取 Cookiesif 'num' in request.COOKIES['num']: num = request.COOKIES['num']else: num = 0 Session123456789101112131415161718# 设置 Sessionrequest.session['num'] = 1return HttpResponse('...')# 读取 Sessionif 'num' in request.session['num']: num = request.session['num']else: num = 0# 或num = request.session.get('num', '0') # 也可以设置默认值# 清除 Session 的值request.session.clear()# 删除 Session 记录request.session.flush()# 删除 某一个键del request.session['key']# 设置会话超时时间，单位：秒。默认两周；为0，则关闭浏览器过期request.session.set_expiry(24*3600) 设计分页我们也可以使用index?page=1的方式传递GET参数，分页也一般采用这种方式查看当前访问的是第几页。通过GET参数获取请求的分页，为了获取GET参数，可以使用如下：12345page = request.GET.get('page') # 字符串，可能没有这个参数if page: page = int(page)else: page = 1 Django自带了分页组件。分页组件及其常用方法如下：1234567891011121314from django.core.paginator improt Paginatorp = Paginator(one_list, 3) # one_list列表, 每页3个记录p.num_pages # 分了几页 p.page_range # 总记录数page = p.page(1) # 获取第一页page.number # 当前页页码page.object_list # 第一页的查询集page.paginator # 对应的分页器page.has_next() # 是否有下一页page.has_previous() # 是否有上一页page.previous_page_number # 前一页页码page.next_page_number # 后一页页码 Django 路由Path 语法Django Path默认支持五个转化器： 12345str：匹配除了路径分隔符（/）之外的非空字符串，这是默认的形式int：匹配正整数，包含0。slug：匹配字母、数字以及横杠、下划线组成的字符串。uuid：匹配格式化的uuid，如 075194d3-6885-417e-a8a8-6c931e272f00。path：匹配任何非空字符串，包含了路径分隔符 具体用法例如： 123456urlpatterns = [ path('articles/2003/', views.special_case_2003), path('articles/&lt;int:year&gt;/', views.year_archive), path('articles/&lt;int:year&gt;/&lt;int:month&gt;/', views.month_archive), path('articles/&lt;int:year&gt;/&lt;int:month&gt;/&lt;slug&gt;/', views.article_detail),] 用户也可以自定义转化器，自定义的转化器需要使用实现转化器接口。实现方法如下：123456789101112131415161718192021222324252627282930# 例 1class IntConverter: # 正则表达式 regex = '[0-9]+' # value是匹配到的字符串，返回Python变量 def to_python(self, value): return int(value) # value是Python变量，返回字符串，用于url反向引用 def to_url(self, value): return str(value)# 例 2class StringConverter: regex = '[^/]+' def to_python(self, value): return value def to_url(self, value): return value# 例 3：匹配4位整数class FourDigitYearConverter: regex = '[0-9]&#123;4&#125;' def to_python(self, value): return int(value) def to_url(self, value): return '%04d' % value 定义完成后，将其注册到配置中。在需要的urls.py中添加：12345678from django.urls import register_converterfrom . import converters # 自制转化器，不嫌乱也可以把自制转化器放到urls.py中。register_converter(converters.FourDigitYearConverter, 'yyyy')urlpatterns = [ path('articles/&lt;yyyy:year&gt;/', views.year_archive),] 如果嫌自制转化器太繁琐，可以使用兼容Django 1中的正则表达式的方式直接匹配。123456urlpatterns = [ path('articles/2003/', views.special_case_2003), re_path('articles/(?P&lt;year&gt;[0-9]&#123;4&#125;)/', views.year_archive), re_path('articles/(?P&lt;year&gt;[0-9]&#123;4&#125;)/(?P&lt;month&gt;[0-9]&#123;2&#125;)/', views.month_archive), re_path('articles/(?P&lt;year&gt;[0-9]&#123;4&#125;)/(?P&lt;month&gt;[0-9]&#123;2&#125;)/(?P&lt;slug&gt;[^/]+)/', views.article_detail),] Django 模板模板加载顺序加载一个模板，首先是查找配置的模板目录，如果找不到，再去INSTALLED_APPS下的templates查找。这一过程是Django自动的。 模板变量模板变量，不能以下划线开头。1&#123;&#123; num &#125;&#125; 下面两种情况，有两种解析顺序。1&#123;&#123; author.name &#125;&#125; 其解析顺序为: 作为字典，取键值 作为对象，取属性 作为对象，当作对象的方法 都无法匹配，则替换为空字符串 1&#123;&#123; author_list.0 &#125;&#125; 其解析顺序为: 作为字典，取键值 作为列表，取下标 都无法匹配，则替换为空字符串 模板标签后端给标签变量赋值可以使用render函数。123render(request, 'index.html', &#123; 'author_list': AuthorModel.objects.all()&#125;) 前端的模板标签主要如下1234567891011121314151617181920for循环标签&#123;% for x in author_list %&#125;列表不为空时&#123;&#123; forloop.counter &#125;&#125; 记录循环第几次&#123;% empty %&#125;列表为空时&#123;% endfor %&#125;if标签&#123;% if 条件 %&#125;操作符旁边必须有空格&#123;% elif %&#125;&#123;% else %&#125;&#123;% endif %&#125;注释&#123;# 单行注释 #&#125;&#123;% comment %&#125;多行注释&#123;% endcomment %&#125; 模板过滤器过滤器是用在前端的标签函数，用于对模板变量做操作。12345678910过滤器格式为&#123;&#123; 变量|过滤器:参数 &#125;&#125;改变日期的显示格式&#123;&#123; book.publish_date|date:"Y年-m月-d日" &#125;&#125;求长度&#123;&#123; book.title|length &#125;&#125;设置默认值&#123;&#123; book.title|default:"No Title" &#125;&#125;自定义过滤器（是否是奇数）&#123;&#123; author.age|mod:1 &#125;&#125; 自定义过滤器的定义应在my_app目录下的templatetags下。templatetags应该有一个__init__.py文件，保证该目录可以被Python识别。 这里创建一个filters.py文件用于开发自定义过滤器。自定义标签也可以写到这里。filters.py123456789101112131415from django import templateregister = template.Library()# value：被判断的变量；arg：传入的参数def mod(value, arg): return value % arg# 完成后，注册过滤器register.filter('mod', mod)# 另外，只有一个参数的过滤器如下，外加另外一种注册方式@register.filter(name='lower')def lower(value): # Only one argument. return value.lower() 在需要使用的模板上加载过滤器。1&#123;% load filters %&#125; 模板继承网页往往会有很多重复的内容，因此我们可以制作一个父页面，子页面继承主页面显示以减少重复代码。 父页面base.html12345678910111213&lt;!DOCTYPE html&gt;&lt;html lang="en"&gt;&lt;head&gt; &lt;meta charset="UTF-8"&gt; &lt;title&gt;Title&lt;/title&gt;&lt;/head&gt;&lt;body&gt;&lt;h1&gt;Hello&lt;/h1&gt;&#123;% block topics %&#125;默认显示内容&#123;% endblock topics %&#125;&lt;/body&gt;&lt;/html&gt; 子页面sub_page.html123456789&#123;% extends 'base.html' %&#125;&#123;% block topics %&#125;新内容获取父模板的内容&#123;&#123; block.super &#125;&#125;&#123;% endblock topics %&#125; 模板转义默认情况下，模板上下文（由后端传递过来）中的html标记会被转义显示，即模板中的&lt;&gt;会被转化为&amp;lt;&amp;gt。因此要关闭转义显示，可以使用标签1234567方式 1&#123;&#123; 变量|safe &#125;&#125;方式 2&#123;% autoescape off %&#125;模板语言代码&#123;% endautoescape %&#125; Django 用户登录登录装饰器有些页面是用户登录之后才可以访问的，例如修改密码，修改昵称等，也就是这些页面首先要进行用户登录的判断，否则让用户跳转回登录页面。 我们可以通过函数装饰器的方式：12345678910111213141516# 定义一个闭包函数def login_required(view_func): def wrapper(request, *view_args, **view_kwargs) # 判断用户是否登录 if true: return view_func(request, *view_args, **view_kwargs) else: return redirect('/login') pass return wrapper# 使用函数装饰器，使用该函数会先调用login_required，相当于# login_required(change_pwd)(request, *view_args, **view_kwargs)@login_requireddef change_pwd(request): return HttpResponse('Change Password') CSRF 攻击CSRF 攻击即跨站请求伪造攻击。我们在访问某一网站时，例如银行网站，在访问的结束后再去访问其他的网站，就会致使我们所有保存在浏览器上的数据包都会暴露给第三方网站，如果第三方网站上有某些攻击脚本，例如在用户不知情的情况下，再次利用刚才的数据包（SessionID）访问银行网站进行一些危险的操作，我们的数据就会产生泄露甚至丢失的危险。 由于伪造的网站与真实的网站的IP或主机名是不一样的，所以根据这一特性，我们可以也防止这种跨站请求伪造攻击。 Django 默认是启用这种 CSRF 攻击保护的（只针对POST），但同时也带来了不便，因为我们有时自己的网站也会被防护，导致自己的网站都无法正常浏览。 解决这一问题，可以在模板中的表单里添加如下内容即可。1&#123;% csrf_token %&#125; 内置表单Django中内置了表单。用户可以通过Django内置的表单生成器自动生成表单。 1234567891011121314151617181920212223from django import formsclass LoginForm(forms.Form): username = forms.TextField() password = forms.TextField(widget=forms.PasswordInput)def login_handler(request): if request.method == "POST": login_form = LoginForm(request.POST) if login_form.is_valid(): user = login_form.cleaned_data['username'] pswd = login_form.cleaned_data['password'] if user: # 验证用户名，密码 return HttpResponse('成功登录') else: return HttpResponse('登录失败') else: return HttpResponse("输入不合法")def login(request): login_form = LoginForm() return render(request,'login.html', &#123;"forms":login_form&#125;) 12345&lt;form action="." method="post"&gt; &#123;% csrf_token %&#125; &#123;&#123; forms &#125;&#125; &lt;input type="submit" value="Login"&gt;&lt;/form&gt; 验证码django-simple-captcha 官方文档首先按照验证码库： 1pip install django-simple-captcha 在项目settings.py中配置：123456789101112131415161718192021INSTALLED_APPS = [ ... "captcha",]# Captcha 二者选其一# 字母验证码CAPTCHA_IMAGE_SIZE = (80, 45) # 设置 captcha 图片大小CAPTCHA_LENGTH = 4 # 字符个数CAPTCHA_TIMEOUT = 1 # 超时(minutes) # 加减乘除验证码CAPTCHA_OUTPUT_FORMAT = '%(image)s %(text_field)s %(hidden_field)s 'CAPTCHA_NOISE_FUNCTIONS = ('captcha.helpers.noise_null', 'captcha.helpers.noise_arcs', # 线 'captcha.helpers.noise_dots', # 点)CAPTCHA_CHALLENGE_FUNCT = 'captcha.helpers.random_char_challenge'CAPTCHA_CHALLENGE_FUNCT = 'captcha.helpers.math_challenge'CAPTCHA_TIMEOUT = 1 在项目urls.py中配置：1path('captcha/', include('captcha.urls')) 完成后迁移数据库12python manage.py makemigrationpython manage.py migrate 创建登录表单，验证码在登录时由表单自动完成验证。123456789101112131415161718192021222324from django import formsfrom captcha.fields import CaptchaFieldclass LoginForm(forms.Form): username = forms.TextField() password = forms.TextField(widget=forms.PasswordInput) captcha = CaptchaField()def login_handler(request): if request.method == "POST": login_form = LoginForm(request.POST) if login_form.is_valid(): user = login_form.username if user: '''用户登陆后，Django会自动调用默认的session应用，将用户的id存至session中''' return HttpResponse('成功登录') else: return HttpResponse('登录失败') else: return HttpResponse("输入不合法")def login(request): login_form = LoginForm() return render(request,'login.html', &#123;"forms":login_form&#125;) 如果想要点击验证码实现验证码更新，则可以使用如下操作（需要jQuery）。 123456789101112131415from captcha.helpers import captcha_image_urlfrom captcha.models import CaptchaStoreimport jsondef captcha_refresh(request): """ Return json with new captcha for ajax refresh request """ if not request.is_ajax(): # 只接受ajax提交 raise Http404 new_key = CaptchaStore.generate_key() to_json_response = &#123; 'key': new_key, 'image_url': captcha_image_url(new_key), &#125; return HttpResponse(json.dumps(to_json_response), content_type='application/json') 123456789101112131415161718192021222324252627282930&lt;script&gt; $(function()&#123; # 改变鼠标箭头 $('.captcha').css(&#123; 'cursor': 'pointer' &#125;) # ajax 刷新 $('.captcha').click(function()&#123; console.log('click'); $.getJSON("/captcha/refresh/", function(result)&#123; $('.captcha').attr('src', result['image_url']); $('#id_captcha_0').val(result['key']) &#125;);&#125;); # ajax动态验证 $('#id_captcha_1').blur(function()&#123; // #id_captcha_1为输入框的id，当该输入框失去焦点是触发函数 json_data=&#123; 'response':$('#id_captcha_1').val(), // 获取输入框和隐藏字段id_captcha_0的数值 'hashkey':$('#id_captcha_0').val() &#125; $.getJSON('/ajax_val', json_data, function(data)&#123; //ajax发送 $('#captcha_status').remove() if(data['status'])&#123; //status返回1为验证码正确， status返回0为验证码错误， 在输入框的后面写入提示信息 $('#id_captcha_1').after('&lt;span id="captcha_status" &gt;*验证码正确&lt;/span&gt;') &#125;else&#123; $('#id_captcha_1').after('&lt;span id="captcha_status" &gt;*验证码错误&lt;/span&gt;') &#125; &#125;); &#125;); &#125;)&lt;/script&gt; 当然，高级玩家可以自己画验证码。下面自制验证码： 安装Pillow包1pip install Pillow 定义一个验证码生成函数12345678910111213141516171819202122232425262728293031323334353637383940414243from PIL import Image, ImageDraw, ImageFontfrom django.utils.six import BytesIOdef verify_code(request): import random # 背景色，宽，高 bgcolor = (random.randrange(20, 100), random.randrange(20, 100), 255) width = 100 height = 25 # 创建画面 img = Image.new('RGB', (width, height), bgcolor) draw = ImageDraw.Draw(img) # 绘制噪点 for i in range(0, 100): xy = (random.randrange(0, width), random.randrange(0, height)) fill = (random.randrange(0, 255), 255, random.randrange(0, 255)) draw.point(xy, fill=fill) # 准备字符串 str_back = 'ABCDEFGHIJKLMNOPQRSTUVWXYZ1234567890' rand_str = '' for i in range(0, 4): rand_str += str_back[random.randrange(0, len(str_back))] # 绘制字符串 font = ImageFont.truetype('FreeMono.ttf', 23) fontcolor = (255, random.randrange(0, 255), random.randrange(0,255)) for i in range(0, 4): draw.text((5 + 24*i, 2), rand_str[i], font=font, fill=fontcolor) # 释放画笔 del draw # 存储验证码到后端 request.session['verify_code'] = rand_str # 保存到内存文件 buf = BytesIO() im.save(buf, 'png') # 返回验证码 return HttpResponse(buf.getvalue(), 'image/png') URL 反向解析在模板里面，可以将链接到其他页面的超链接写成动态的，这样可以保证修改链接后自动修改所有链接到某页的路径。 在项目urls.py中，添加namespace属性：1234url_patterns = [ ... path('my_app/', include('my_app.urls', namespace='my_app'))] 在应用urls.py配置中，添加name属性：1234url_patterns = [ ... path('index_renamed/', views.index, name='index')] 在模板中：12345用法：url 'namespace:name' 参数&lt;a href="&#123;% url 'my_app:index' %&#125;"&gt;首页&lt;/a&gt;&lt;a href="&#123;% url 'my_app:index' arg1 arg2 %&#125;"&gt;带位置参数的首页&lt;/a&gt;&lt;a href="&#123;% url 'my_app:index' a=arg1 b=arg2 %&#125;"&gt;带关键字参数的首页&lt;/a&gt; 在视图中使用反向解析：1234567from django.core.urlresolvers import reversedef test_redirect(request): # 'namespace:name' url = reverse('my_app:index', args=('arg1', 'arg2')) url = reverse('my_app:index', kwargs=&#123;'a'='arg1', 'b'='arg2'&#125;) return redirect(url) 中间件是Django预留的函数接口，允许我们干预请求和应答。例如对客户端进行过滤，防止DDoS攻击等。 中间件可以允许我们在执行视图函数之前自动执行中间件。中间件的执行流程如下：1234567891011st=&gt;start: 请求到达服务器op1=&gt;operation: 产生Request对象op2=&gt;operation: 调用process_requestop3=&gt;operation: 匹配URLop4=&gt;operation: 调用process_viewop5=&gt;operation: 调用视图函数op6=&gt;operation: 调用process_responseop6=&gt;operation: 返回给浏览器e=&gt;endst-&gt;op1-&gt;op2-&gt;op3-&gt;op4-&gt;op5-&gt;op6-&gt;e 在setting.py中注册中间件，注册顺序与执行顺序相反。1234MIDDLEWARE = [ ... 'my_app.middleware.Block_Middleware'] 在my_app目录下建立middleware.py文件，编辑此文件：12345678910111213141516171819202122# 中间件类class Block_Middleware(object): # 匹配url之后，在进入视图函数之前调用 def process_view(self, request, view_func, *view_args, **view_kwargs): # 获取浏览器端的IP地址： user_ip = request.META('REMOTE_ADDR') if user_ip in ['127.0.0.1']: return HttpRequest('Go Back') # 服务器启动后接受第一个请求的时候调用 def __init__(self): pass # 产生request之后，匹配url路由之前调用 def process_request(self, request): pass # 调用视图函数之后，返回浏览器之前调用 # view_func 为将要调用的视图函数 def process_response(self, request, response): return response # 视图函数异常时候调用 def process_exception(self, request, exception): pass 注意：如果在中间件的任意一个函数返回response，后续的过程将不会执行，而是直接将结果交给process_response，再返回浏览器。 Django Shell就是带Django相关功能的Python Shell。可以方便开发者调试代码。例如，使用Django Shell添加一条数据库的记录。首先进入Shell1python manage.py shell 进入后，可以执行如下常用操作：12345from my_app.models import AuthorModel, MyBookModelfrom datetime import date# 获取作者A的所有书 的 第0本，注意要所有字母小写print(a.mybookmodel_set.all()[0]) Django Admin 模块Django标配的后台管理工具，使用方便，可以快速编辑很多内容。 首先创建用户：1python manage.py createsuperuser 填写用户名与密码，这里可能要求密码长度大于8位且不能为纯数字。 之后运行查看效果：1python manage.py runserver 8080 http://127.0.0.1:8080/admin/ 进入后台后，可以看到管理页面中出现 Groups 与 Users，编辑这两项添加用户与用户组。如果想将my_app的模型MyModel也加入其中，可以到my_app下的admin.py中编辑： 123from my_app.models import MyBookModel, AuthorModeladmin.site.register(MyBookModel)admin.site.register(AuthorModel) 也可以使用自定义管理页面：123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263class MyBookModelAdmin(admin.ModelAdmin): # 浏览页 # 显示的字段，方法 list_display = ['id', 'title', 'title_func'] # 如果想让传过来的方法也可以排序，要做模型里面添加 # title_func.admin_order_field = 'title' # 如果想改变显示内容 # title_func.short_description = 'T' # 如果想改变字段的显示内容 # title = models.CharField(verbose_name='T', max_length=20) # 每一页显示多少条 list_per_page = 10 # 动作 actions_on_bottom = True actions_on_top = False # 过滤栏 list_filter = [ 'title' # 列表页右侧的过滤栏 ] # 搜索框 search_fields = [ 'title' # 列表页上方的搜索框 ] # 编辑页 # 字段显示顺序 fields = [ 'title', 'id' ] # 分组显示 fieldsets = [ ('Base', &#123;'fields': ['title', 'id']&#125;), ('Advance', &#123;'fields': []&#125;) ] # 关联对象 inlines = [ AreaStackedInline, AreaTabularInline ]# 块状class AreaStackedInline(admin.StackedInline): # 写多类的名字 model = AreaInfo extra = 2 # 额外新建编辑2个子对象# 表状class AreaTabularInline(admin.TabularInline): # 写多类的名字 model = AreaInfo extra = 2 # 额外新建编辑2个子对象admin.site.register(MyBookModel, MyBookModelAdmin)admin.site.register(AuthorModel) 如果要重写模板，可以在templates下建立base_site.html文件：1234567891011121314151617181920&#123;% extends "admin/base.html" %&#125;&#123;# 标题 #&#125;&#123;% block title %&#125;&#123;&#123; title &#125;&#125; | &#123;&#123; site_title|default:_('Django site admin') &#125;&#125;&#123;% endblock %&#125;&#123;# 展框 #&#125;&#123;% block branding %&#125;&lt;h1 id="site-name"&gt; &lt;a href="&#123;% url 'admin:index' %&#125;"&gt; &#123;&#123; site_header|default:_('Django administrator') &#125;&#125; &lt;/a&gt;&lt;/h1&gt;&#123;% endblock %&#125;&#123;# 导航栏 #&#125;&#123;% block nav-global %&#125;&#123;% endblock %&#125; Django 上传配置settings.py文件：12MEDIA_URL = '/static/media'MEDIA_ROOT = os.path.join(BASE_DIR, 'my_app/static/media') 模板上，上传图片的表单配置如下：12345&lt;form method="post" action="/my_app/upload_action" enctype="multipart/form-data"&gt; &#123;% csrf_token %&#125; &lt;input type="file" name="pic"/&gt;&lt;br/&gt; &lt;input type="submit" value="upload file"/&gt;&lt;/form&gt; 视图中，获取文件并保存：12345678910111213141516def upload_handle(request): # 如果是小文件（&lt;2.5MB），则文件存储在内存中；如果是大文件（&gt;2.5MB），则文件存储在临时文件中。 image = request.FILES['pic'] # image.name：文件名 # image.chunks()：返回一个列表，里面存储文件的每一个区块 # image.size：文件大小 # image.content_type：文件类型，但是不确定 # 创建一个文件 save_path = '%s/my_book_model/%s'%(settings.MEDIA_ROOT, image.name) with open(save_path, 'wb') as f: for chk in image.chunks(): f.write(chk) # 将路径保存至数据库中 m = MyBookModel.objects.get(id=1) m.picture = 'my_book_model/%s'%image.name m.save() 开发流程总结需求分析网站设计数据库设计URL设计 URL 视图 模板文件 /login login login.html 创建项目模型编辑视图编辑路由配置其他虚环境虚环境的安装12sudo pip install virtualenv # 虚环境sudo pip install virtualenvwrapper # 虚环境扩展 虚环境的常用命令1234mkvirtualenv -p python3 name # 创建虚环境deactivate # 退出虚环境workon name # 进入虚环境rmvirtualenv name # 删除虚环境 查看虚环境下已安装的包12pip list # 列出所有的包pip freeze &gt; requirements.txt # 输出安装的包（到文件） MySQL基本操作开启日志文件，需要修改mysql.conf文件。12# 实时查看日志文件tail -f mysql.log]]></content>
      <categories>
        <category>Web 开发</category>
      </categories>
      <tags>
        <tag>Django</tag>
        <tag>Web</tag>
        <tag>Python</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[VSCode 开发调试C++ 程序]]></title>
    <url>%2F2020%2F01%2F25%2FVSCodeCPPInit%2F</url>
    <content type="text"><![CDATA[配置编译环境 MinGW-64点击进入MinGW-64下载页面，下载完毕后，解压到一个固定的目录下，并将该目录的../bin目录添加至环境变量中。 打开CMD（或Power Shell）输入gcc测试环境是否配置成功。如果成功，则显示： 12gcc: fatal error: no input filescompilation terminated. 下载 Visual Studio Code点击下载Visual Studio Code，下载完毕后安装打开。进入程序后，在插件栏中安装Code Run，C/C++两款插件。安装完毕后重启编辑器。 Tips: 可以安装一个Chinese插件可以进行汉化。 创建第一个项目打开一个空文件夹，在其下面创建.vscode文件夹（注意有个点），依次点击菜单栏的调试-&gt;添加配置选项，添加一个C++(GDB/LLDB)配置，第二步选择g++.exe build and debug active file，之后会启动调试，并显示调试失败。这里点击取消，编辑器将自动创建launch.json文件和tasks.json文件，这个文件中可以配置启动程序和调试程序所需的相关内容。这两个文件默认情况下是不需要修改的。如果调试失败，可以参考如下两个配置文件进行修改。文件内容如下： launch.json1234567891011121314151617181920212223242526&#123; "version": "0.2.0", "configurations": [ &#123; "name": "(gdb) Launch", // 配置名称 "type": "cppdbg", // 这里只能为cppdbg "request": "launch", // 请求配置类型，可以为launch（启动）或attach（附加） "program": "$&#123;fileDirname&#125;/$&#123;fileBasenameNoExtension&#125;.exe",// 将要进行调试的程序的路径 "args": [], // 程序调试时传递给程序的命令行参数，一般设为空即可 "stopAtEntry": false, // 设为true时程序将暂停在程序入口处，一般设置为false "cwd": "$&#123;workspaceFolder&#125;", // 调试程序时的工作目录，一般为$&#123;workspaceFolder&#125;即代码所在目录 "environment": [], "externalConsole": true, // 调试时是否显示控制台窗口，一般设置为true显示控制台 "MIMode": "gdb", "miDebuggerPath": "gdb.exe", // miDebugger的路径，注意这里要与MinGw的路径对应 "preLaunchTask": "g++", // 调试会话开始前执行的任务，一般为编译程序，c++为g++, c为gcc "setupCommands": [ &#123; "description": "Enable pretty-printing for gdb", "text": "-enable-pretty-printing", "ignoreFailures": true &#125; ] &#125; ] &#125; tasks.json12345678910111213141516171819202122232425&#123; // See https://go.microsoft.com/fwlink/?LinkId=733558 // for the documentation about the tasks.json format "version": "2.0.0", "tasks": [ &#123; "type": "shell", "label": "g++", "command": "g++.exe", "args": [ "-g", "$&#123;file&#125;", "-o", "$&#123;fileDirname&#125;\\$&#123;fileBasenameNoExtension&#125;.exe" ], "options": &#123; "cwd": "" &#125;, "problemMatcher": [ "$gcc" ] &#125; ]&#125; 配置完成后，添加一个简单的CPP文件，分别调试、直接运行一次测试功能是否正确。如果发现不能调试程序，可尝试重启编辑器。 main.cpp1234567#include &lt;iostream&gt;int main(void)&#123; std::cout&lt;&lt;"Hello World..."&lt;&lt;std::endl; return 0;&#125;]]></content>
      <categories>
        <category>开发技巧与开发工具</category>
      </categories>
      <tags>
        <tag>C/C++</tag>
        <tag>Visual Studio Code</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Git的使用方法]]></title>
    <url>%2F2020%2F01%2F17%2FGitUse%2F</url>
    <content type="text"><![CDATA[Git 的介绍与安装Git具有版本控制与合作开发的特点。它是一个分布式的版本控制系统，代码不仅在服务器上保存代码的完整版，还在各个客户端保存完整代码的副本。这个服务器可以是Github，也可以是自己搭建的代码管理系统，如Gitlab，码云等。 点击进入Git下载页面。 GIT的基本结构 工作区工作区就是当前的Git目录。 版本库版本库就是该目录下的.git目录。 暂存区暂存区就是用户执行add操作后，临时修改被放置的位置。暂存区的文件经过commit命令可以被提交到分支中（创建一个版本）。 GIT本地仓库的基本操作本节将介绍：Git仓库的初始化，版本切换，版本日志的查看，工作区修改情况查看，撤销等命令，命令如下：12345678910git init resp_name # 代码仓库初始化git add . # 添加所有改动到暂存区git commit -m "..." # 提交暂存区内容，形成版本git log # 打印当前版本库git reflog # 打印操作记录git reset --hard HEAD^ # 切换到上上个版本git checkout -- file_name # 将暂存区的文件恢复到工作区（丢弃工作区的改动）git reset HEAD file_name # 将版本库中的文件恢复到暂存区git diff HEAD -- file_name # 对比工作区文件与版本库文件的区别git diff HEAD HEAD^ -- file_name # 对比两个版本的某文件的区别 本地仓库的创建与提交新建一个目录，之后我们要在这里开发一个项目（编写代码）。首先使用Git Bash在该目录下执行，初始化一个Git仓库： 1git init 或1git init repository_name 完毕后，Git将创建一个版本控制系统在该目录下。之后我们创建一个文件，简单的编写一些内容，用于验证后面的版本控制的功能。例如，我们创建一个code.txt文件。内容如下： code.txt1Hello 保存退出，在Git Bash中执行以下命令，添加修改到工作区，并提交修改： 12git add . git commit -m '新增并初始化了code.txt文件' 这里的.表示该目录下的所有文件，也可以写某一个文件，还可以使用*.txt等格式书写；add操作表示将相应文件加入到版本控制系统中；commit命令表示提交修改，-m的参数表示相应的备注。 版本的切换输入如下命令，可以查看当前所有的代码版本。 1git log 或使log以简短形式呈现 12git log --pretty=onelinegit log --graph --pretty=oneline # 含有图形展示 下面我们创建第二个版本。修改刚刚的code.txt文件，内容如下 code.txt12HelloWorld 再次执行 12git add . git commit -m '修改了code.txt文件内容' 则我们添加了一个新的版本到我们的版本库中。执行git log即可查看到两个版本。 图中的commit 后的 1f96fe… 与 2f88a26… 则是对应的两个版本的版本代号。 那么如何回退到某一个版本？Git的版本是后一个版本依赖于前一个版本的，也就是后面的版本只记录修改的部分。所有的版本组成了一个链表，而HEAD指针永远指向的最新的版本。如果想找到上一个版本，可以使用HEAD^或HEAD~1；上两个版本，可以使用HEAD^^或HEAD~2。 Tips：HEAD实际上会指向master，而master才指向最新的版本。关于分支的部分可以到下一节查看。这里可以暂时理解为HEAD指向最新的版本。 回退到上一个版本，可以使用命令 1git reset --hard HEAD^ 打开文件code.txt可以看到，文件内容已经恢复到最初的版本了。如果又想切换到最新的版本，则可以使用命令 1git reset --hard 版本编号 版本编号可以使用git reflog命令，通过查看操作记录寻找版本编号。 恢复工作区的文件当工作区被编辑后，如果不知道已经做过哪些修改了，可以通过下面的命令查看当前工作区被修改的情况。 1git status 如果想撤销工作区中某一个文件的修改，可以使用如下命令 1git checkout -- 文件名 如果想撤销暂存区中某一个文件的修改，可以使用如下命令，使修改回归暂存区。回归暂存区后，再使用checkout命令使其回到工作区。 1git reset HEAD 文件名 如何对比文件与文件的不同？ 对比工作区与版本库中的文件的不同：使用diff命令，需要给出被对比的版本和文件名。1git diff HEAD -- 文件名 会输出其中的---表示版本库中的文件，+++表示工作区中的文件。下方的红色部分表示工作区中的文件相对于版本库删掉的部分，绿色的是添加的部分。 对比版本库中两个版本的文件的不同：使用diff命令，并给出被对比的两个版本和文件名。1git diff HEAD HEAD^ -- 文件名 这里输出的时候，---表示版本库中的HEAD版本，+++表示HEAD^版本。如果命令写成git diff HEAD^ HEAD，则---与+++所表示的内容也相反。 其他命令如果想删除某一个文件，并将这一改动添加到暂存区，可以使用git add命令，表示添加改动到暂存区；也可以使用git rm命令，表示添加删除操作到暂存区。示例如下： 1git rm 文件名 Git 的分支管理在Git中，所谓分支就是一个指针。例如master分支，就是一个master指针指向了该版本链表的某一个节点。如果是其他分支，例如dev分支，则是在这个链表上添加一个叫dev的指针，指向某一个版本节点。最终再由HEAD指针指向当前编辑的分支指针，也就是HEAD指向了当前编辑的分支。 分支的合并，就是将master指针指向dev所指节点，即图中第四个节点。这样就将dev分支合并到master分支当中了。 分支的删除，就是直接删除dev指针，这样就删掉了该分支。 分支的基本操作如下：123456789git branch # 查看所有分支git branch dev # 创建dev分支git branch -d dev # 删除dev分支git checkout master # 切换到master分支git checkout -b dev # 创建并切换到dev分支git merge dev # 合并dev分支到当前分支git stash # 临时存储工作区git stash list # 列出所有的工作区git stash pop # 恢复顶层的工作区 分支的查看，创建与切换使用下述命令，可以查看当前的所有分支。1git branch 如果要创建某一分支，可以使用这个命令（dev为分支名称）。1git branch dev 进行分支切换，可以直接使用如下命令。 1git checkout master 或创建并切换分支，可以一步到位，使用这个命令。1git checkout -b dev 切换的过程，就是由HEAD指向master指针变为了HEAD指向dev指针。新建的分支保留了原有分支的所有版本，也就是版本链表前边的部分，dev与master是共同享有的。这时，我们不论是add与commit操作，还是log操作，均是在dev分支上进行的。 分支的合并与分支管理当要进行分支合并，使用如下命令，但是分支合并，必须要在被合并的分支上进行，例如要将dev分支合并到master上，需要先切换到master分支上再执行合并操作。 1git merge dev 合并分为三种情况：有冲突的合并；没有冲突的快速合并；没有冲突的普通合并。 快速合并：只修改新的分支，原有分支不动。例如master指针可以直接指向dev指针的位置上，无需产生新的版本，也不会留下分支创建的记录。 没有冲突的普通合并（recursive合并）：两个分支上都有新版本产生，但是没有修改同一个文件。这种情况会在合并后产生一个新的版本。在执行合并操作后会提示提交新版本需要填写的信息。 有冲突的合并：两个分支上都有新版本产生，且修改了同一个文件。这会在合并后先产生合并失败，需要待手动修改冲突后再手动提交新的版本。 对于有冲突的合并，合并失败后，有冲突的文件会产生类似于如下内容的部分。通过手动修改这部分的内容，可以解决合并冲突。修改后，再次执行add与commit操作即可完成合并。 12345&lt;&lt;&lt;&lt;&lt;&lt; HEAD # 删除多余部分，保留需要的部分原分支的更改（被合并的分支）========新传入的更改&gt;&gt;&gt;&gt;&gt;&gt;&gt; dev 有时为了保留分支的创建与合并的记录，我们会在合并时候禁用快速合并模式。执行方式如下：1git merge --no-ff -m "提交信息" dev 合并后，就可以删除dev分支了。这里使用如下命令删除dev分支。 1git branch -d dev Bug 分支与 stash 功能当我们遇到紧急Bug需要修复时，但又不能将当前的工作区提交到版本控制系统中，就可以使用stash功能。 1git stash stash功能可以将我们的工作区临时存储起来，存储完成后，工作区恢复到最近版本，就可以先去完成修复Bug的工作了。 修复bug时，首先创建bug分支，其次完成bug修复工作，完成后将bug分支合并到master分支即可。 待完成修复Bug的工作后，再去将我们原来的工作区恢复，继续进行工作。使用如下命令可以看到我们保存的所有的工作现场。 1git stash list 使用如下命令可以恢复工作现场。 1git stash pop Github 的使用之前的操作都是在本地计算机上所做的。但是我们合作开发的时候，往往需要借用Github之类的代码托管系统。Github的使用，与我们在本地使用Git类似，只是多了拉取与推送等操作。 创建代码仓库首先需要有一个Github账号，登录后点击New repository，输入仓库名称，配置相应设置后，点击Create repository即可。 .gitignore文件：保存了不需要同步的文件列表。 添加SSH如果是初次使用Github，需要配置SSH。 点击用户头像-&gt;settings-&gt;ssh and gpg keys-&gt;new ssh key，在这里添加SSH标题与电脑的SSH公钥。 电脑的SSH公钥生成方式：12cd ~/.ssh/ # 如果提示`No such file or directory`，可以手动的创建一个.ssh文件夹ssh-keygen -t rsa -C "your_email@youremail.com" 之后按提示输入两遍密码，这个密码可以自己设置一个。也可以什么都不写，直接两次回车键。 用记事本打开.ssh目录下的id_rsa.pub文件，复制里面的内容，到github添加即可。这个公钥也可以移动到其他电脑上使用，用于用户在push时登录Github账号使用，这里建议每台计算机一个公钥。 使用这个命令可以测试SSH是否配置正确。1ssh -T git@github.com 使用这两个命令填写用户的用户名和用户邮箱，这里主要是为了在commit时显示是谁提交的代码。这个配置会被保存到用户目录/.gitconfig文件中。12git config --global user.name "account" git config --global user.email "your_email@youremail.com" 后面的Push操作中，还会需要输入一次Github账号密码，这个账号密码与上面的邮箱和账号并不冲突，这个信息只会显示在commit记录上，而Push时输入的账号密码则是用来保证用户访问Github使用的。如果要修改本机上用于Push代码的Github账号密码，可到控制面板-&gt;用户账户-&gt;管理Windows凭据-&gt;普通凭据-&gt;git:https://user_name@github.com下修改。 Clone 代码我们先找到放置项目的目录，使用clone命令将项目克隆到本地。1git clone git@github.com:user_name/repo_name 或1git clone https://github.com/user_name/repo_name 如果在克隆的过程中出现错误，可以使用如下命令修复。 12eval "$(ssh-agent -s)"ssh-add Push 代码当代码克隆下来后，首先创建一个自己的分支进行开发。开发完成后，再提交到本地代码库。 12git add .git commit -m "..." 积累到一定的开发量，如果要推送到远程服务器，则使用如下命令进行远程推送。 1git push origin dev 其中origin是远程分支（这个名字固定），dev为本地的分支（这个名字随便起）。执行完毕后，远程仓库将创建dev分支。 首次Push时，可能会提示填写Github账号与密码。 如果本地仓库和远程仓库都有代码，且不是一套代码，这里可以使用强推操作。这样的强制操作应该尽量慎重使用。 1git push -f 也可以先将远程仓库代码与本地代码合并再推送。12git fetchgit merge 跟踪远程分支将本地分支跟踪服务器分支。跟踪后，Git将智能提示用户当前分支与服务器分支的进度差别。1git branch --set-upstream-to=origin/远程分支名称 本地分支名称 跟踪后，可以直接使用如下代码推送代码。1git push 拉去远程分支1git pull origin 远程分支名 拉去后，分支会默认进行跟踪。 管理远程分支 Remote 命令查看远程已存在的分支：1git remote 添加远程仓库，将远程仓库绑定到origin上：1git remote add origin 远程仓库 查看远程仓库：1git remote -v 可以删除远程主机：1git remote rm 主机名 可以修改主机名：1git remote rename 原主机名 新主机名 工作中使用Git 项目经理搭建项目框架，并放入代码管理工具。 普通员工在自己电脑上生成SSH公钥，交给项目经理。项目经理将SSH公钥上传至服务器。 项目经理给组员分发代码的克隆地址。组员将代码克隆到自己的电脑上。 普通员工创建自己的分支，在分支中进行每天的开发。 注意Master分支要保持发布的代码，Dev分支用于保存开发中的代码。 组员要把自己的Dev分支发布到远程Dev分支当中，但是发布之前需要确认代码可用，需要经过经理确认。 VS Code GIT在VS Code中可以看到如下图标，这个图标就是VS Code的Git可视化管理工具。 点击该按钮（源代码管理），点击+，选择当前文件夹，初始化Git本地仓库。这时，Git本地仓库就建立好了。 修改文件夹中的文件，再切换到源代码管理中，将鼠标移动到被修改的文件，可以看到右侧出现了+，点击+可以将操作暂存到暂存区。如果想取消暂存，可以再点-即可。如果选中了某个文件，可以在右侧预览该文件与工作区文件的区别。 最上方有一个√，这个是提交按钮，点击√后即可提交该版本到版本控制中。 如果想回退到某版本，还是需要借助命令行来实现。这里可以使用插件Git History查看某个版本，复制其ID，方便在命令行操作。 如果想添加远程仓库，也需要借助命令行。可以先执行初始化本地仓库操作，在本地版本库还是空的时候去pull远程代码。也可以跳过初始化操作，直接克隆远程代码。如果在本地版本库不是空的时候直接去pull代码，会出现下面的错误。 1fatal: refusing to merge unrelated histories 这时可以使用下面的命令强行拉取，这样Git就会不论之前的版本库是否一致，都会去拉去远程分支。 1git pull https://github.com/用户名/仓库名.git master --allow-unrelated-histories Visual Studio 2017（待更新）PyCharm GIT（待更新）创建本地Git仓库。VCS-&gt;VCS Operation Popup-&gt;Create Git Repositry 再次点击VCS，会与之前有所区别。左侧的文件菜单，文件名也会有颜色的变换。 右键左侧某文件或文件夹-&gt;Git-&gt;Add，将选中文件添加到版本控制中；或者在提交的时候，可以在上方的文件管理器中勾选。 查看版本历史VCS-&gt;Browse VCS Repository-&gt;Show Git Repository Log 如果想回退到某一个版本，可以右键一个版本，选择Checkout Revision。 如果想切换分支VCS-&gt;Git-&gt;Branches 使用远程仓库添加远程仓库：VCS-&gt;Checkout from Version Control 填写远程仓库地址与本地目录：https://github.com/用户名/仓库名.git 会有提示：Would you like to open ...这样就可以打开下载的代码了。 右键左侧某文件或文件夹-&gt;Git-&gt;Repository-&gt;Push推送代码到远程仓库。 PyCharm 其他技巧VCS-&gt;Git-&gt;Annotate 可以看到每一行代码的作者和日期。 自带版本控制，可以查看本地代码版本。在这里可以直接切换代码版本。VCS-&gt;Local History 参考视频 Git 版本管理链接：https://pan.baidu.com/s/1ua94DTk1MkUBlILNDN7LHQ提取码：m4un]]></content>
      <categories>
        <category>开发技巧与开发工具</category>
      </categories>
      <tags>
        <tag>Git</tag>
        <tag>版本管理</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[开发信息汇总]]></title>
    <url>%2F2020%2F01%2F14%2FWebInfoA%2F</url>
    <content type="text"><![CDATA[设计模式MVC 架构MVC 架构是Web前端，Web后端的常用架构，也是一些桌面端应用程序，手机程序的常用架构。 Model：模型，是网站访问数据库的接口。View：视图，用户能够看到的页面。Controller：控制器，用于操作数据库，处理用户业务，控制用户行为的程序。 三者的划分即是从功能的角度划分，也是从数据的处理流程的划分。一般流程为：用户发出请求-&gt;控制器处理请求-&gt;模型获取数据-&gt;视图渲染界面-&gt;用户得到反馈 ORM 框架Object：对象Relatioin：关系，MySQL中的表Mapping：映射 利用ORM框架，使对象与关系表对应，对象的属性与关系表中的字段对应，通过操作类和对象的方式来编辑修改数据库。 事件驱动Web 概念前端后端前后端分离Ajax 技术Ajax 是一种在无需重新加载整个网页的情况下，能够更新部分网页的技术。通过在后台与服务器进行少量数据交换，Ajax 可以使网页实现异步更新。这意味着可以在不重新加载整个网页的情况下，对网页的某部分进行更新。 这里就要建议用户使用IE6+以上的版本，因为之前的版本的Ajax技术的使用方法和主流浏览器不一样。如果非得使用旧版IE，那就要单独为旧版IE写一套代码了（使用jQuery框架可以屏蔽这种差异）。当然不止是Ajax，一些CSS也需要另外写一套。 CGI，WSGI 与 ASGICGI：CGI脚本简单地讲是个运行在Web服务器上的程序, 由浏览器的输入触发。这个脚本通常象服务器和系统中其他程序如数据库的桥梁。CGI是一种古老的Web技术，一般有C/C++编写，是PHP等语言出现之前就有的产物。当然，也可以用Lua，Python来编写。 WSGI：是一种服务器和客户端交互的接口规范，规定客户与服务器如何通信。 ASGI：由Django团队首创，支持WebSocket，HTTP2等服务。 运维理念GIT敏捷开发CI CD数据库常用数据库介绍数据库分类数据库分为关系型数据库和非关系型数据库。关系型数据库如MySQL，Oracle，SQL Server，SQLite等，是基于关系表的存储结构存储数据。而非关系型数据库如Redis，MongoDB等采用键值对、图等各种方式存储数据。这两类没有优劣之分，只有适用场景之分。 在关系型数据库中，一个关系（表）代表一个对象，每个关系都有多个属性（字段）。关系与关系之间也有着一对一、一对多、多对多的关联，例如老师与课程是一对多的关联，课程与学生是多对多的关联等。 关系型数据库的属性属性也分为超键，主键，候选键，外键以及普通字段。 假设有如下两个表： 学生（学号，姓名，性别，身份证号，教师编号）教师（教师编号，姓名，工资） 超键：在表中能唯一标识记录的属性集称为超键。学生表中含有学号或者身份证号的任意组合都为此表的超键。如（学号）（学号，姓名）（身份证号，性别）等。 候选键：不含有多余属性的超键称为候选键。也就是候选键属于超键，它是最小的超键，就是说如果再去掉候选键中的任何一个属性它就不再是超键了。学生表中的候选键为（学号）（身份证号）。 主键：用户选作元组标识的一个候选键程序主键。主键就是候选键里面的一个，是人为规定的，例如学生表中，我们通常会让“学号”做主键，教师表中让“教师编号”做主键。 外键：如果关系模式R1中的某属性集不是R1的主键，而是另一个关系R2的主键则该属性集是关系模式R1的外键。学生表中的外键就是“教师编号”。外键主要是用来描述两个表的关系。 关系型数据库的属性依赖字段直接含有依赖关系。一般分为三种依赖关系：部分依赖，完全依赖，传递依赖。 部分依赖：设X，Y是关系R的两个属性集合，存在X→Y，若X’是X的真子集，存在X’→Y，则称Y部分依赖于X。例如：通过AB能得出C，通过A也能得出C，通过B也能得出C，那么说C部分依赖于AB。 完全依赖：设X，Y是关系R的两个属性集合，X’是X的真子集，存在X→Y，但对每一个X’都有X’!→Y，则称Y完全依赖于X。例如：通过AB能得出C，但是AB单独得不出C，那么说C完全依赖于AB. 传递依赖：设X，Y，Z是关系R中互不相同的属性集合，存在X→Y，Y→Z，，Y !→X，Z !→Y则称Z传递依赖于X。例如：通过A得到B，通过B得到C，但是C得不到B，B得不到A，那么成C传递依赖于A。 关系型数据库的设计范式设计数据库也要讲究原则，我们把这些原则叫做范式。一般情况下，我们设计数据库只需满足五大范式中的前三个范式。五大范式有： 第一范式 1NF：强调的是列的原子性，即列不能够再分成其他几列。每一列只代表一个属性，不能是多个属性的合并。例如，姓名和性别不能存储到一列中，而是应该存储在两列中。 第二范式 2NF：所有的非主属性都完全依赖于关键字。第二范式不存在非主属性对于部分候选关键字的部分依赖，不过允许非主属性之间存在着传递依赖。 下面是第二范式的优化实例： 假定选课关系表为： SelectCourse(学号，姓名，年龄，课程名称,成绩，学分)关键字为组合关键字：(学号，课程名称)因为存在如下决定关系：(学号，课程名称) → (姓名，年龄，成绩，学分) 这个数据库表不满足第二范式，因为存在如下决定关系： (课程名称) → (学分)(学号) → (姓名，年龄) 即存在组合关键字中的字段决定非关键字的情况。 由于不符合2NF，这个选课关系表会存在如下问题： (1) 数据冗余：同一门课程由n个学生选修，”学分”就重复n-1次；同一个学生选修了m门课程，姓名和年龄就重复了m-1次。 (2) 更新异常：若调整了某门课程的学分，数据表中所有行的”学分”值都要更新，否则会出现同一门课程学分不同的情况。 (3) 插入异常：假设要开设一门新的课程，暂时还没有人选修。这样，由于还没有”学号”关键字，课程名称和学分也无法记录入数据库。 (4) 删除异常：假设一批学生已经完成课程的选修，这些选修记录就应该从数据库表中删除。但是，与此同时，课程名称和学分信息也被删除了。很显然，这也会导致插入异常。 因此，把选课关系表SelectCourse改为如下三个表： 学生：Student(学号,姓名，年龄)；课程：Course(课程名称，学分)；选课关系：SelectCourse(学号，课程名称，成绩)。 这样的数据库表是符合第二范式的，消除了数据冗余、更新异常、插入异常和删除异常。 另外，所有单关键字的数据库表都符合第二范式，因为不可能存在组合关键字。 第三范式 3NF：每一个非主属性既不部分依赖于也不传递依赖于关键字，也就是在第二范式的基础上消除传递依赖（A＞B＞C）。 假定学生关系表为： Student(学号，姓名，年龄，所在学院,学院地点，学院电话) 关键字为单一关键字： “学号” 因为存在如下决定关系： (学号) → (姓名，年龄，所在学院，学院地点，学院电话) 这个数据库是符合2NF的，但是不符合3NF，因为存在如下决定关系： (学号) → (所在学院) → (学院地点，学院电话) 即存在非关键字段”学院地点”、”学院电话”对关键字段”学号”的传递依赖。 它也会存在数据冗余、更新异常、插入异常和删除异常的情况，读者可自行分析得知。 把学生关系表分为如下两个表： 学生：(学号，姓名,年龄，所在学院) 学院：(学院，地点，电话) 这样的数据库表是符合第三范式的，消除了数据冗余、更新异常、插入异常和删除异常。 BCNF：在第三范式的基础上进一步消除主属性对于码的部分依赖和传递依赖。BCNF需要符合3NF，并且，主属性不依赖于主属性。 假设仓库管理关系表为 StorehouseManage(仓库ID,存储物品ID,管理员ID,数量)且有一个管理员只在一个仓库工作；一个仓库可以存储多种物品。这个数据库表中存在如下决定关系：(仓库ID,存储物品ID) →(管理员ID,数量) (管理员ID,存储物品ID) → (仓库ID,数量) 所以，(仓库ID,存储物品ID)和(管理员ID,存储物品ID)都是StorehouseManage的候选关键字，表中的唯一非关键字段为数量，它是符合第三范式的。但是，由于存在如下决定关系： (仓库ID) → (管理员ID) (管理员ID) → (仓库ID) 即存在关键字段决定关键字段的情况，所以其不符合BCNF范式。它会出现如下异常情况： (1) 删除异常： 当仓库被清空后，所有”存储物品ID”和”数量”信息被删除的同时，”仓库ID”和”管理员ID”信息也被删除了。 (2) 插入异常： 当仓库没有存储任何物品时，无法给仓库分配管理员。 (3) 更新异常： 如果仓库换了管理员，则表中所有行的管理员ID都要修改。 因此，把仓库管理关系表分解为二个关系表： 仓库管理：StorehouseManage(仓库ID,管理员ID) 仓库：Storehouse(仓库ID,存储物品ID,数量) 这样的数据库表是符合BCNF范式的，消除了删除异常、插入异常和更新异常。 但是也有例外。又如，有这样一个配件管理表： WPE(仓库号，配件号，职工号，QNT) 有以下约束要求： （1）一个仓库有多名职工； （2）一个职工仅在一个仓库工作； （3）每个仓库里一种型号的配件由专人负责，但一个人可以管理几种配件； （4）同一种型号的配件可以分放在几个仓库中。 分析表中的依赖关系，可以得到： （1）职工号 -&gt; 仓库号; （2）（仓库号，配件号）-&gt; 数量 （3）（仓库号，配件号）-&gt; 职工号 （4）（职工号，配件号）-&gt; 数量 可以看到，候选键有：（职工号，配件号）(仓库号，配件号)。所以，职工号，配件号，仓库号均为主属性，数量为非主属性。显然，非主属性是直接依赖于候选键的。所以此表满足第三范式。 而我们观察一下主属性：（仓库号，配件号）-&gt; 职工号；职工号 -&gt; 仓库号。显然仓库号对于候选键（仓库号，配件号）存在传递依赖，所以不符合BCNF. 解决这个问题的办法是分拆为两个表 管理表EP（职工号，配件号，数量）工作表EW（职工号，仓库号）但这样做会导致依赖（仓库号，配件号）-&gt; 职工号丢失。虽然，不满足BCNF，也会导致一些冗余和一致性的问题。但是，将表分解成满足BCNF的表又可能丢失一些依赖。所以，一般情况下不会强制要求关系表要满足BCNF。&gt; 第四范式 4NF：当一个表中的非主属性互相独立时（3NF），这些非主属性不应该有多值。若有多值就违反了第四范式。有这样一个用户联系方式表TELEPHONE(CUSTOMERID,PHONE,CELL)CUSTOMERID为用户ID，PHONE为用户的固定电话，CELL为用户的移动电话。本来，这是一个非常简单的第3范式表。主键为CUSTOMERID，不存在传递依赖。但在某些情况下，这样的表还是不合理的。比如说，用户有两个固定电话，两个移动电话。这时，表的具体表示如下：| CUSTOMERID | PHONE | CELL ||———————|—————-|————-||1000 | 8828-1234 | 149088888888||1000 | 8838-1234 | 149099999999|由于PHONE和CELL是互相独立的，而有些用户又有两个和多个值。这时此表就违反第四范式。在这种情况下，此表的设计就会带来很多维护上的麻烦。例如，如果用户放弃第一行的固定电话和第二行的移动电话，那么这两行会合并吗？等等解决问题的方法为，设计一个新表NEW_PHONE(CUSTOMERID,NUMBER,TYPE)这样就可以对每个用户处理不同类型的多个电话号码，而不会违反第四范式。显然，第四范式的应用范围比较小，因为只有在某些特殊情况下，要考虑将表规范到第四范式。所以在实际应用中，一般不要求表满足第四范式。&gt; 第五范式 5NF：是最终范式。消除了4NF中的连接依赖。第五范式有以下要求：（1）必须满足第四范式（2）表必须可以分解为较小的表，除非那些表在逻辑上拥有与原始表相同的主键。第五范式是在第四范式的基础上做的进一步规范化。第四范式处理的是相互独立的多值情况，而第五范式则处理相互依赖的多值情况。有一个销售信息表SALES（SALEPERSON，VENDOR，PRODUCT）SALEPERSON代表销售人员，VENDOR代表供和商，PRODUCT则代表产品。在某些情况下，这个表中会产生一些冗余。可以将表分解为PERSON_VENDOR表（SALEPERSON，VENDOR）PERSON_PRODUCT表（SALEPERSON，PRODUCT）VENDOR­_PRODICT表（VENDOR，PRODUCT） 参考 1：超键，主键，候选键，外键参考 2：五大范式参考 3：依赖关系]]></content>
      <categories>
        <category>Web 开发</category>
      </categories>
      <tags>
        <tag>Web开发</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[ROS 基础]]></title>
    <url>%2F2019%2F04%2F13%2FRosBase-1%2F</url>
    <content type="text"><![CDATA[近期做的东西和ROS有关，因此想做一些关于ROS的笔记。这篇文章主要分为以下几个部分。 ROS简介 ROS的工程架构 ROS的计算图集 ROS工具包 未完结 1. ROS简介ROS（Robot OS）是运行在Ubuntu上的次级系统，它内部由多个节点构成，每个节点即一个进程。这些节点之间各自分工，又相互合作，共同完成一些列任务。一般一个ROS工程由master节点和多个子节点构成，master负责管理各个节点，而子节点则负责各自具体的任务。 2. ROS的工程架构对于一个ROS工程，它一般分为三部分： build：编译产生的中间文件； devel：编译的结果文件； src：源代码目录。 项目架构概览 /catkin_ws /build /devel /src /folder_1 /package_1 /package_2 /folder_2 /package_3 /package_4 /metapackage 一个ROS工程的src部分，是由一个个Package组成的。每个Package一般对应一个应用或是一个节点。另外还有一类特殊的Package，叫做Metapackage，即虚包，它们没有自己的内容，但是由很多依赖，因此常用来做功能集使用。 Package架构概览： /package /msg x.msg /srv x.srv /action x.action /scripts x.py x.sh /launch x.launch /config x.yaml /include x.h /src x.cpp /other_dirs other_files CMakeLists.txt package.xml ROS支持C++和Python开发。在一个Package下，script下一般存放python文件，src、include文件夹下面分别存放了c++的.cpp文件和.h文件。launch文件夹下存放了ROS的启动文件，这些启动文件描述了这个包的启动过程中需要定义的参数，需要依赖的其它的包等内容。config文件夹下存放了一些配置文件，通过yaml语言定义。ROS自带了三种通信方式，其中msg描述了通过topic方式通信过程中的数据格式，srv、action则分别保存了service和action通信的数据格式。 3. ROS的计算图集计算图集，也叫通信架构，是ROS节点之间通信的工具。ROS节点之间的通信方式共有三种。 TopicTopic是最常见的通信方式，topic是一个独立于节点的存在。每个节点既可以发布topic，也可以订阅topic。发布者会始终无条件的发布消息，所以不论有没有其他节点在订阅消息，都会按照一定频率发布topic。并且topic的发布者可以不只是一个节点，偶尔也会有多个节点在同一个topic上发布消息。当然，订阅topic的节点也可以是多个。 一个节点如果想发布topic，必须先创建一个msg，这个msg就像是一个结构体，节点可以在这个msg中存放一些数据，然后发布到topic上。另一个节点如果想订阅这个topic，就必须按照这个msg的结构进行监听。 msg文件结构12float32 xfloat32 y Service当进行一些复杂的，计算量大的任务时，Topic却无法胜任这种情况了，因为Topic是不论有没有订阅者，发布者都会无条件发布消息，这就会导致大量的计算资源被浪费了。而Service这种通信方式正是弥补了这一缺陷。Service会根据服务请求者的请求，按需执行，因此大大节约了计算资源。 Service由服务的提供方提供相应服务，而请求方需要按照srv文件中定义的格式向服务提供方请求服务。 srv文件结构123456// 请求格式uint32 id---// 响应格式float32 xfloat32 y Action对于一些执行时间较长的服务，服务的请求方还需要知道服务的实时进度。这时候Action就派上用场了。Action除了像服务那样按需执行外，在执行的过程中，也会按照一定的频率向请求方发送一些其他的数据，这些数据都是在action文件中定义的。 action文件结构123456789// 请求格式uint32 id---// 结果格式float32 xfloat32 y---// 中间反馈格式string state 数据格式文件中的数据类型12345678boolstringint8, int16, int32, int64uint8, uint16, uint32, uint64float32, float64time, durationvariable-length array[], fixed-length array[C]other msg files 4. ROS工具包Gazebo 物理仿真工具可以对机器人进行物理仿真，可以对机器人设置重量，碰撞模型，转动惯量等设置。 Rviz 机器人可视化工具主要用于机器人调试，数据可视化操作。 MoveIt! 机械臂路径规划工具专门用于机械臂控制使用，里面集成了大量的关于机械臂的工具包。 Rqt ROS代码调试工具提供了一系列代码调试工具： rqt_graph 绘制计算图（通信架构图）rqt_plot 绘制数据变化曲线rqt_console 查看日志的工具rqt_* 其他工具 5. 未完结（停止更新）]]></content>
      <categories>
        <category>ROS</category>
      </categories>
      <tags>
        <tag>ROS</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Github 博客搭建]]></title>
    <url>%2F2019%2F03%2F29%2FGitBlogInit%2F</url>
    <content type="text"><![CDATA[经过几天的研究，我终于搭起了一个Github博客网站。这篇文章将从以下几个步骤分别介绍博客的搭建。 前期准备 环境部署 配置域名（可选） 配置到个人服务器（可选） 附录 1. 前期准备首先，你需要拥有以下内容： Github账号个人域名（可选）个人服务器（可选） Github账号可以到Github官网申请，过程很简单，这里就不赘述了。个人域名可以选择阿里云，腾讯云等域名产品，申请过程也就不说了，这个不是必选，有需要的可以搞一个。 2. 环境部署这一步就正式开始搭建自己的博客了。首先是安装一些软件： GitNodeJS Git的安装过程首先到Git下载页面下载Git，这里建议下载64-bit Git for Windows Setup版本，涉及到一些环境变量的配置，安装版可以自动配置环境变量，省去手动配置的烦恼（32位系统则选择32-bit版）。 NodeJS的安装过程到NodeJS下载页面下载NodeJS，可以选择Windows 安装包 (.msi) x64版，原因同上。 安装博客框架可以选择Hexo，Jekyll等博客框架。这里以Hexo为例(参考文档，博客主题在这个官网中可以查看）。打开终端，执行如下命令安装（这一步需要管理员模式）：1npm install -g hexo 在本地新建一个目录，执行init命令初始化Hexo和Git： 12hexo initgit init 配置Github创建一个Repository，名字必须为your_user_name.github.io。（加粗部分替换为自己的用户名）下面配置SSH Key方便后续上传博客代码。在本地Git Bash中输入如下命令建立SSH Key：1ssh-keygen -t rsa -C "邮箱地址" -f ~/.ssh/github_blog_keys 中间会提示你输入文件，密码，可以不用管，直接回车即可。配置成功后，打开生成的ssh-key，新生成的公钥就是~/.ssh/github_blog_keys.pub。到在自己的账户设置中，找到 SSH and GPG keys ，点击New SSH Key 添加新的Key。将刚刚生成的公钥文件中的内容复制这里即可。 之后我们需要配置自己的Username和Email：12git config --global user.name "your_user_name" git config --global user.email "your_email" 之后将本地仓库再关联到远程仓库，首先复制远程仓库地址，到Git Bash中执行下述命令，这一步要保证当前打开的路径是Hexo的路径：1git remote add origin https://github.com/your_user_name/your_user_name.github.io.git 配置Hexo在Hexo目录下执行下面这句，安装该扩展程序。1npm install hexo-deployer-git --save 打开Hexo下的_config.yml文件，在文件末尾添加：1234deploy: type: git repository: git@github.com:your_user_name/your_user_name.github.io.git branch: master 并修改title，url，theme等配置。 开始编写下面就可以开始编写自己的博客了。执行下面命令新建Hexo页面。1hexo new "HelloWorld" 之后会在项目的/source/_post/下看到HelloWorld.md文件，使用MarkDown语言编辑这个文件即可。编辑完毕保存退出，执行下述命令开始编译项目并上传：1hexo g -d 打开连接https://your_user_name.github.io 就能看到你的博客了。也可以在本地看看效果：1hexo s 打开连接http://localhost:4000 即可看到效果。 3. 配置域名（可选）首先得需要一个域名（还得是备案过的）。这里以腾讯云的域名为例。在云解析服务中，选择你的域名点击右侧的解析，进入域名的配置页面。点击上方的添加记录，主机类型可以选www或者@，记录类型选择CNAME，记录值为your_user_name.github.io. （注意末尾有个点），之后保存即可。在你的项目中的/source/目录下创建CNAME文件，文件内容是你的一级域名，如下所示： your_user_name.cn 保存编译上传项目，过几分钟后即可配置成功。如果要开启HTTPS，则还需要购买SSH证书（有免费的证书），例如可以选择阿里云，腾讯云或CloudFlare的免费HTTPS服务。这里以腾讯云为例，选择为期一年的免费版SSH证书。在云产品中找到SSH 证书管理，点击申请免费证书，选择左侧的免费一年的证书。按照上面的要求输入相关信息，点击下一步，等待几分钟审核通过（也可能好久）。回到https://github.com/your_user_name/your_user_name.github.io 中，进入仓库设置页面，下拉找到GitHub Pages，在Custom domain中输入自己的域名，并开启Enforce HTTPS。 4. 配置到个人服务器（可选，Ubuntu版）当然，首先需要一台个人服务器。配置过程主要分为几个步骤： 安装Git-core安装Nginx配置Https 首先安装Git-core和Nginx。登入服务器执行如下代码1sudo apt-get install git-core nginx openssh-server 安装成功后，开始配置Nginx。在这里我们可以使用SSL给网站加点安全措施。首先从腾讯云上下载SSL证书（笔者用Chrome下载证书时浏览器会崩溃，于是换了一个浏览器才下载下来），压缩包下会有Nginx版对应的证书。复制里面的证书到服务器上，这里可以使用xftp或MobaXterm的sftp上传，放到 /etc/nginx/cert 目录下。在 /etc/nginx 下执行下述代码:1234sudo cp sites-available/default sites-available/default-sslsudo ln -s sites-available/default-ssl sites-enabled/sslsudo rm sites-enabled/defaultsudo vim sites-enabled/ssl 开始使用vim编辑刚刚得到的ssl文件，配置ssl访问，并设置80端口重定向到443端口。12345678910111213141516171819202122232425262728293031server &#123; # SSL configuration listen 443 ssl default_server; listen [::]:443 ssl default_server; root /home/git/tmp/blog; # Add index.php to the list if you are using PHP index index.html index.htm index.nginx-debian.html; server_name www.your_domain.com; ssl on; ssl_certificate /etc/nginx/cert/your_crt_file.crt; ssl_certificate_key /etc/nginx/cert/your_key_file.key; ssl_session_timeout 5m; ssl_protocols TLSv1 TLSv1.1 TLSv1.2; ssl_ciphers ECDHE-RSA-AES128-GCM-SHA256:HIGH:!aNULL:!MD5:!RC4:!DHE; ssl_prefer_server_ciphers on; location / &#123; try_files $uri $uri/ =404; &#125;&#125;server &#123; listen 80; listen [::]:80; location / &#123; rewrite ^(.*)$ https://$host$1 permanent; &#125;&#125; 配置完成后，记得在腾讯云的域名解析上添加一条A记录，来指向自己的服务器IP地址。完成后别忘了访问一下自己的网站，看看是否能够访问成功。下面开始部署网站到自己的服务器上了。在自己的服务器上，首先搭建一个Git的服务器。首先将之前的github_blog_keys.pub中的公钥上传到服务器上，保存到 ~/.ssh/authorized_keys 文件中。在自己的服务器中创建git账号。12sudo username gitsudo passwd git 输入git账号的密码，之后登陆到git账号中，创建仓库。123456su gitcd ~git --bare init blog.git# 这两步后面有用mkdir tmpmkdir tmp/blog 这里回到本地，先测试一下能否正常访问自己的git。1git clone git@your_server_ip:~/blog.git 成功后利用hexo将博客代码部署到自己的服务器上。首先先配置自己的_config.yml文件。打开_config.yml文件，修改deploy部分的代码：1234567deploy: - type: git repository: git@github.com:your_user_name/your_user_name.github.io.git branch: master - type: git repository: git@your_server_ip:~/blog branch: master 保存后使用hexo提交博客代码。12hexo cleanhexo g -d 这样就可以提交代码到服务器上保存了。但是目前网站依然是无法访问的，需要再编写一个自动部署网站的脚本。进入服务器，进入到目录 /home/git/blog.git/hooks 下，创建提交后执行的脚本。12345#!/bin/bash -lGIT_REPO=/home/git/blog.gitTMP_GIT_CLONE=/home/git/tmp/blogrm -rf $&#123;TMP_GIT_CLONE&#125;git clone $GIT_REPO $TMP_GIT_CLONE 创建完成后，修改一下权限，并重启Nginx。123chmod +x post-receivechmod 777 -R /home/git/tmp/blogservice nginx restart 这次在客户端用hexo重新部署一次代码。1hexo d 到此结束，可以收工了。 附录A Hexo常用命令Hexo初始化1hexo init 编译到静态页面12hexo generate # 简写 hexo g 部署到Github上12hexo deploy # 简写 hexo d 使用本地浏览器查看 ( http://localhost:4000 )12hexo server # 简写 hexo s 创建新的Page1hexo new 配置主题 _config.yml首先给Hexo配置一个主题，之后就可以在Hexo的主题的目录下看到_config.yml文件。以NexT主题为例，目录下的_config.yml文件中有如下选项： Site Information Settings 站点信息设置 SEO Settings SEO设置 Menu Settings 菜单设置，包括显示的栏目，栏目图标等 Scheme Settings 主题风格设置 Sidebar Settings 菜单栏设置，包括友情链接，个人头像，侧边栏位置等 Post Settings 主页文章显示设置 Misc Theme Settings 主题其他设置，字体，代码风格等 Third Party Services Settings 第三方服务，数学插件，评论插件，统计插件，搜索插件等 Tags Settings 标签设置 Animation Settings 动画设置 创建分类与标签使用如下两个命令分别创建分类与标签：1234# 创建分类hexo new page categories# 创建标签hexo new page tags 创建完成后，需要在主题配置中开启相应的选项（例如NexT主题中的menu）。 安装插件图片本地化插件在Hexo目录下执行下面语句：1npm install https://github.com/CodeFalling/hexo-asset-image --save 之后配置根目录下的_config.yml中：1post_asset_folder:true 之后再创建文章的时候，就会同时在同一目录下创建一个与文章同名的文件夹，里面可以存放文章中使用到的图片。在文章中引用文件夹下的图片pic.jpg方法如下：1![image](pic.jpg) 评论插件这里推荐两款评论插件，来必得与LeanCloud。来必得支持多账号登录，但是评论数据无法导出，而LeanCloud是匿名评论，提供的对象存储支持每日30,000次请求，总共10GB存储。 搜索插件这里使用Local Search，直接安装即可实现本地搜索。安装代码如下：1npm install hexo-generator-searchdb --save 回到博客的_config.yml中添加如下设置：12345search: path: search.xml field: post format: html limit: 10000 在主题的_config.yml中找到local_search，并启用该功能：123# Local searchlocal_search: enable: true 动态壁纸线条背景：在主题文件夹下找到layout/_layout.swig文件，在&lt;/body&gt;上方添加代码123&#123;% if theme.canvas_nest %&#125;&lt;script type="text/javascript" src="//cdn.bootcss.com/canvas-nest.js/1.0.0/canvas-nest.min.js"&gt;&lt;/script&gt;&#123;% endif %&#125; Live2D插件首先安装Live2D插件：1npm install --save hexo-helper-live2d 这里推荐到xiazeyu这里找一个喜欢的模型安装一下，我随便选一个为例：1npm install --save live2d-widget-model-hibiki 回到博客的_config.yml文件中，在最后添加代码，具体可以看EYHN里面的介绍：12345678910111213141516171819# Live2D## https://github.com/EYHN/hexo-helper-live2dlive2d: enable: true # enable: false scriptFrom: local # 默认 pluginRootPath: live2dw/ # 插件在站点上的根目录(相对路径) pluginJsPath: lib/ # 脚本文件相对与插件根目录路径 pluginModelPath: assets/ # 模型文件相对与插件根目录路径 # scriptFrom: jsdelivr # jsdelivr CDN # scriptFrom: unpkg # unpkg CDN # scriptFrom: https://cdn.jsdelivr.net/npm/live2d-widget@3.x/lib/L2Dwidget.min.js # 你的自定义 url tagMode: false # 标签模式, 是否仅替换 live2d tag标签而非插入到所有页面中 debug: false # 调试, 是否在控制台输出日志 model: use: live2d-widget-model-hibiki # npm-module package name # use: wanko # 博客根目录/live2d_models/ 下的目录名 # use: ./wives/wanko # 相对于博客根目录的路径 # use: https://cdn.jsdelivr.net/npm/live2d-widget-model-wanko@1.0.5/assets/wanko.model.json # 你的自定义 url]]></content>
      <categories>
        <category>Web 开发</category>
      </categories>
      <tags>
        <tag>Git</tag>
        <tag>Github</tag>
        <tag>Blog</tag>
        <tag>博客</tag>
      </tags>
  </entry>
</search>
